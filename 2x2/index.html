<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WCA Scramble Statistics</title>
    <link rel="stylesheet" href="../styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
</head>
<body>
    <h1><a id="event-header" href="../">2x2</a></h1>
    <select id="csv-selector" onchange="updateSubOptions()">
        
        <option value="Best_Groups">Best Groups</option>
        
        <option value="All_X_Movers">All X Movers</option>
        
        <option value="Distributions">Distributions</option>
        
        <option value="Scramble_Sequences">Scramble Sequences</option>
        
    </select>

    <!-- Secondary Dropdown for Subcategories -->
    <select id="sub-csv-selector" onchange="displaySelectedCSV()">
        <!-- This will be dynamically populated -->
    </select>

    <div id="csv-data"></div>

    <script>
        const csvFiles = {
            
            'Best_Groups': ['Best_Groups/Optimal_Ao5.csv', 'Best_Groups/Optimal_Layer_Ao5.csv', 'Best_Groups/Best_Possible_Optimal_Ao5.csv', 'Best_Groups/Optimal_Mo5.csv', 'Best_Groups/Optimal_Face_Ao5.csv', 'Best_Groups/Optimal_Layer_Mo5.csv', 'Best_Groups/Optimal_Face_Mo5.csv'],
            
            'All_X_Movers': ['All_X_Movers/All_4_Movers.csv', 'All_X_Movers/All_11_Movers.csv', 'All_X_Movers/All_5_Movers.csv'],
            
            'Distributions': ['Distributions/Optimal_QTM_Distribution.csv', 'Distributions/Number_of_Repeated_Scrambles_Distribution.csv', 'Distributions/Optimal_HTM_Distribution.csv', 'Distributions/Number_of_Repeated_States_(with_symmetries)_Distribution.csv'],
            
            'Scramble_Sequences': ['Scramble_Sequences/Most_Half_Turns_in_a_Scramble.csv', 'Scramble_Sequences/Most_Clockwise_Turns_in_a_Scramble.csv', 'Scramble_Sequences/All_States_Repeated_10+_Times.csv', 'Scramble_Sequences/All_Scrambles_Repeated_4+_Times.csv', 'Scramble_Sequences/Most_Counter_Clockwise_Turns_in_a_Scramble.csv'],
            
        };

        const subCategoryNames = {
            
            'Best_Groups/Optimal_Ao5.csv': 'Optimal Ao5',
            
            'Best_Groups/Optimal_Layer_Ao5.csv': 'Optimal Layer Ao5',
            
            'Best_Groups/Best_Possible_Optimal_Ao5.csv': 'Best Possible Optimal Ao5',
            
            'Best_Groups/Optimal_Mo5.csv': 'Optimal Mo5',
            
            'Best_Groups/Optimal_Face_Ao5.csv': 'Optimal Face Ao5',
            
            'Best_Groups/Optimal_Layer_Mo5.csv': 'Optimal Layer Mo5',
            
            'Best_Groups/Optimal_Face_Mo5.csv': 'Optimal Face Mo5',
            
            'All_X_Movers/All_4_Movers.csv': 'All 4 Movers',
            
            'All_X_Movers/All_11_Movers.csv': 'All 11 Movers',
            
            'All_X_Movers/All_5_Movers.csv': 'All 5 Movers',
            
            'Distributions/Optimal_QTM_Distribution.csv': 'Optimal QTM Distribution',
            
            'Distributions/Number_of_Repeated_Scrambles_Distribution.csv': 'Number of Repeated Scrambles Distribution',
            
            'Distributions/Optimal_HTM_Distribution.csv': 'Optimal HTM Distribution',
            
            'Distributions/Number_of_Repeated_States_(with_symmetries)_Distribution.csv': 'Number of Repeated States (with symmetries) Distribution',
            
            'Scramble_Sequences/Most_Half_Turns_in_a_Scramble.csv': 'Most Half Turns in a Scramble',
            
            'Scramble_Sequences/Most_Clockwise_Turns_in_a_Scramble.csv': 'Most Clockwise Turns in a Scramble',
            
            'Scramble_Sequences/All_States_Repeated_10+_Times.csv': 'All States Repeated 10+ Times',
            
            'Scramble_Sequences/All_Scrambles_Repeated_4+_Times.csv': 'All Scrambles Repeated 4+ Times',
            
            'Scramble_Sequences/Most_Counter_Clockwise_Turns_in_a_Scramble.csv': 'Most Counter Clockwise Turns in a Scramble',
            
        };

        function updateSubOptions() {
            const primaryCategory = document.getElementById('csv-selector').value;
            const subCsvSelector = document.getElementById('sub-csv-selector');

            // Clear existing options
            subCsvSelector.innerHTML = '';

            // Populate with new subcategory options
            csvFiles[primaryCategory].forEach(file => {
                const option = document.createElement('option');
                option.value = file;
                option.textContent = subCategoryNames[file];
                subCsvSelector.appendChild(option);
            });

            // Automatically display the first subcategory's CSV
            displayCSV(csvFiles[primaryCategory][0]);
        }

        function displayCSV(filename) {
            Papa.parse(filename, {
                download: true,
                skipEmptyLines: true,
                complete: function(results) {
                    const rows = results.data; // PapaParse gives us an array of arrays
                    if (rows.length === 0) return;

                    let rowspans = [];
                    let colTracker = [];
                    const numCols = rows[0].length;

                    // Initialize tracking arrays
                    rows.forEach((_, rowIndex) => {
                        rowspans[rowIndex] = new Array(numCols).fill(1);
                    });
                    colTracker = new Array(numCols).fill(1);

                    // LOOP 1: Calculate Rowspans
                    // We start from index 1 (second row) to compare with the one above
                    for (let i = 1; i < rows.length; i++) {
                        let canCombine = true;

                        for (let j = 0; j < numCols; j++) {
                            // Check if current cell matches cell above AND the previous column also merged
                            if (canCombine && rows[i][j] === rows[i - 1][j]) {
                                colTracker[j]++;
                                // Update the 'root' cell (the one that stays visible) with the new span count
                                rowspans[i - colTracker[j] + 1][j] = colTracker[j];
                                // Mark current cell as 0 so we know to skip it in the HTML loop
                                rowspans[i][j] = 0; 
                            } else {
                                colTracker[j] = 1;
                                canCombine = false; // Break the horizontal "combine" chain
                            }
                        }
                    }

                    // LOOP 2: Generate HTML
                    let table = '<table>';
                    rows.forEach((row, rowIndex) => {
                        table += '<tr>';
                        row.forEach((col, colIndex) => {
                            const span = rowspans[rowIndex][colIndex];

                            if (rowIndex === 0) {
                                // Header Row
                                table += `<th>${col}</th>`;
                            } else {
                                // Only create a <td> if its rowspan is > 0
                                if (span > 0) {
                                    table += `<td rowspan="${span}">${col}</td>`;
                                }
                            }
                        });
                        table += '</tr>';
                    });
                    table += '</table>';

                    document.getElementById('csv-data').innerHTML = table;
                }
            });
        }

        function displaySelectedCSV() {
            const selectedFile = document.getElementById('sub-csv-selector').value;
            displayCSV(selectedFile);
        }

        // Initialize with the first primary category
        updateSubOptions();
    </script>

    <a href="../">Back to main page</a>
</body>
</html>